/**
This is a submission of Lab 4 of CS703 something
@author Antonio Nikolov Trinity College Dublin student number: 10378197
If you have any question, please don't hesitate to email me
You can find the source documentation in the /SkinnedMesh/docs/ folder generated by doxygen
The purpose of this lab was to demonstrate IK
*/
#include "stdafx.h"
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include <luapath\luapath.hpp>
#include "Model.hpp"
#include "GameWorld.hpp"
#include "ModelManager.hpp"
//#include "GameObject.hpp"
//#include "SQTTransform.hpp"
//#include "Camera.hpp"
#include "Timer.hpp"
#include "Curve.hpp"
//#include "CommandQueue.hpp"
#include "Control.hpp"
#include "Command.hpp"
using namespace std;

GLFWwindow* window;
SkinnedObject *robotArm;
SkinnedObject *barbarian;
SkinnedObject *nielsen;
Object *ikLeftArm;

bool pauseRender;


// Function prototypes
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);
void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
void mouse_callback(GLFWwindow* window, double xpos, double ypos);
void mouse_button_callback(GLFWwindow* window, int button, int action, int mods);
void initSubsystems();

int main(int argc, const char* argv[])
{
	//initial setup
	initSubsystems();

	//reset the global timer so we don't get screwy animations on the first frame
	Timer::get().reset();
	pauseRender = false;

	//Main loop
	while (!glfwWindowShouldClose(window))
	{
		// Check and call events
		glfwPollEvents();
		/* Render here */
		glClearColor(0.46f, 0.53f, 0.6f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		if(GameWorld::get().m_PlayIntro)
		{
			GameWorld::get().updateWorldIntro();
			nielsen->update();
		}
		else
		{
			//this where the fun happens
			GameWorld::get().updateWorld();

		}
	

		if(!pauseRender)
		{
			/* Swap front and back buffers */
			glfwSwapBuffers(window);

		}
	}

	glfwTerminate();
	return 0;
}

void initSubsystems(){
	//Custom logger built from Boost::Log
	Logger::initFromFile("config/log.ini");

	//luapath is the bridge between the lua tables stored in lua files and C++
	//we try to throw as much config in external files for extensibility and built time reduction
	luapath::LuaState settings;
	settings.loadFile("config/settings.lua");

	int versionMajor = settings.getGlobalTable("openGL").getValue(".versionMajor");
	int versionMinor = settings.getGlobalTable("openGL").getValue(".versionMinor");

	//Initialize OpenGL and GLFW
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, versionMajor);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, versionMinor);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); 

	if (!glfwInit())
		LOG(FATAL) << "Could not initialize glfw" << endl;

	int screenWidth = settings.getGlobalTable("window").getValue(".width");
	int	screenHeight = settings.getGlobalTable("window").getValue(".height");

	window = glfwCreateWindow(screenWidth, screenHeight,
		string(settings.getGlobalTable("window").getValue(".name")).c_str(), NULL, NULL);
	if (!window)
	{
		LOG(FATAL) << "Could not create window context" << endl;
		glfwTerminate();
	}

	/* Make the window's context current */
	glfwMakeContextCurrent(window);
		//Register callbacks
	glfwSetKeyCallback(window, key_callback);
	glfwSetMouseButtonCallback(window,mouse_button_callback);
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetScrollCallback(window, scroll_callback);

    // Options
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

	GLenum err = glewInit();
	if (GLEW_OK != err)
	{
		LOG(FATAL) << glewGetErrorString(err) << std::endl;
	}
	// Define the viewport dimensions
	glViewport(0, 0, screenWidth, screenHeight);

	glEnable(GL_DEPTH_TEST);
	glEnable(GL_CULL_FACE);
	// Accept fragment if it closer to the camera than the former one
	glDepthFunc(GL_LESS);
	

	GameWorld::get().addSkinnedObject(new SkinnedObject("nielsen", "nielsen", SQTTransform(glm::vec3(0,4,0), glm::vec3(0.5), glm::quat())));

	nielsen = GameWorld::get().getSkinnedObject("nielsen");
	nielsen->generateAABB();

	//set a perspective projection
	GameWorld::get().setProjectionMatrix(glm::perspective(45.0f, (float)screenWidth / (float)screenHeight, 0.1f, 1000.0f));

	//subscribe keys to commands
	//run
	Command *command = new CommandCharacterRun("Player",Direction::FORWARD);
	Control::get().subscribeCommand(command,GLFW_KEY_W);
	command = new CommandCharacterRun("Player",Direction::LEFT);
	Control::get().subscribeCommand(command,GLFW_KEY_A);
	command = new CommandCharacterRun("Player",Direction::RIGHT);
	Control::get().subscribeCommand(command,GLFW_KEY_D);
	//command = new CommandCharacterRun("Player",FORWARD_LEFT);
	//Control::get().subscribeCommand(command,GLFW_KEY_W,GLFW_KEY_A);
	//command = new CommandCharacterRun("Player",FORWARD_RIGHT);
	//Control::get().subscribeCommand(command,GLFW_KEY_W,GLFW_KEY_S);
	
	//walk
	command = new CommandCharacterWalk("Player",Direction::BACKWARD);
	Control::get().subscribeCommand(command,GLFW_KEY_S);
	Control::get().subscribeCommand(command,GLFW_KEY_S, GLFW_KEY_LEFT_SHIFT);
	command = new CommandCharacterWalk("Player",Direction::FORWARD);
	Control::get().subscribeCommand(command,GLFW_KEY_W,GLFW_KEY_LEFT_SHIFT);
	command = new CommandCharacterWalk("Player",Direction::LEFT);
	Control::get().subscribeCommand(command,GLFW_KEY_LEFT_SHIFT,GLFW_KEY_A);
	command = new CommandCharacterWalk("Player",Direction::RIGHT);
	Control::get().subscribeCommand(command,GLFW_KEY_LEFT_SHIFT,GLFW_KEY_D);
	//command = new CommandCharacterWalk("Player",FORWARD_LEFT);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D,GLFW_KEY_LEFT_SHIFT);
	//command = new CommandCharacterWalk("Player",FORWARD_RIGHT);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D,GLFW_KEY_LEFT_SHIFT);
	//command = new CommandCharacterWalk("Player",BACKWARD_LEFT);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_A);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_A,GLFW_KEY_LEFT_SHIFT);
	//command = new CommandCharacterWalk("Player",BACKWARD_RIGHT);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D);
	//Control::get().subscribeCommand(command,GLFW_KEY_S,GLFW_KEY_D,GLFW_KEY_LEFT_SHIFT);

	//fight
	command = new CommandCharacterPrimary("Player");
	Control::get().subscribeCommand(command, GLFW_MOUSE_BUTTON_LEFT);
	Control::get().subscribeCommand(command, GLFW_KEY_LEFT_SHIFT,GLFW_MOUSE_BUTTON_LEFT);
	command = new CommandCharacterSecondary("Player");
	Control::get().subscribeCommand(command, GLFW_MOUSE_BUTTON_RIGHT);
	Control::get().subscribeCommand(command, GLFW_KEY_LEFT_SHIFT,GLFW_MOUSE_BUTTON_RIGHT);


	//test animations
	command = new CommandPlayAnim("Player","wait");
	Control::get().subscribeCommand(command,GLFW_KEY_1);
	command = new CommandPlayAnim("Player","dance");
	Control::get().subscribeCommand(command,GLFW_KEY_2);
	command = new CommandPlayAnim("Player","run");
	Control::get().subscribeCommand(command,GLFW_KEY_3);
	command = new CommandPlayAnim("Player","walk");
	Control::get().subscribeCommand(command,GLFW_KEY_4);
	command = new CommandPlayAnim("Player","lie");
	Control::get().subscribeCommand(command,GLFW_KEY_5);
	command = new CommandPlayAnim("Player","strafeLeft");
	Control::get().subscribeCommand(command,GLFW_KEY_6);
	command = new CommandPlayAnim("Player","strafeRight");
	Control::get().subscribeCommand(command,GLFW_KEY_7);
	command = new CommandPlayAnim("Player","look");
	Control::get().subscribeCommand(command,GLFW_KEY_8);

	command = new CommandPlayAnim("nielsen","chickenRun");
	Control::get().subscribeCommand(command,GLFW_KEY_K);

}

// Is called whenever a key is pressed/released via GLFW
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
    if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);

	if(action == GLFW_PRESS)
        Control::get().press(key);
    else if(action == GLFW_RELEASE)
        Control::get().release(key);
}

void mouse_callback(GLFWwindow* window, double xpos, double ypos)
{
	Control::get().mousePosition(xpos, ypos);
}	

void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
	if(action == GLFW_PRESS)
		Control::get().press(button);
	else if(action == GLFW_RELEASE)
		Control::get().release(button);
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	//
}


